---
title: "포인터"
date: 2022-09-02T19:56:32+09:00
draft: true
tags:
- cpp
categories:
- cs
---
cpp의 포인터에 대해 알아본다.
<!--more-->

# 포인터

일부 언어에서는 메모리의 주소값을 저장하는 포인터 기능을 제공해준다. Java에서는 포인터를 사용해서 직접 메모리 주소에 대한 작업을 하진 않지만, 참조 변수를 통해 포인터와 비슷한 개념으로 프로그래밍을 할 수 있게 만들어준다.

가장 기본적인 포인터 사용법은 다음과 같다.
```cpp
int num = 10;
int *ptr = &num;
```
변수 `num`의 주소를 포인터 변수 `ptr`에 저장하는 것이다. 이렇게 되면 `ptr`은 `num`의 주소를 가리키고 있기 때문에 역참조를 하게 되면 `num`의 값인 10이 나오게 된다.

또한, 포인터는 함수의 주소도 가리킬 수 있다. 함수도 변수와 마찬가지로 메모리에 로드되어 실행되기 때문에 주소를 가지고 있다.

```cpp
void func() {
    cout << "Hello World";
}

int main() {
    cout << func;
    // 00007FF651471451
}
```

`func`라는 함수의 주소를 보고 싶으면 표준 출력 함수에 함수의 이름을 입력하면 된다. 따라서 포인터는 함수의 주소 역시 가리킬 수 있게 된다. 함수 포인터는 다음과 같이 사용할 수 있다.

```cpp
void func() {
    cout << "Hello World";
}

int main() {
    void (*funcPtr) ();
    funcPtr = func;

    funcPtr();
    // Hello World
}
```

함수 포인터를 선언할 때에는 가리키는 함수의 반환 타입과 매개변수에 맞춰서 선언하기만 하면 된다. `funcPtr`이 `func`라는 함수를 가리키고 있기 때문에 이제 함수 포인터를 `func` 함수를 호출하는 것처럼 사용할 수 있게 된다.

## 상수와 포인터

포인터도 변수이기 때문에 `const` 키워드를 사용해서 상수화 시킬 수 있다.

### 상수를 가리키는 포인터

상수를 가리키는 포인터다.(pointer to const)

```cpp
int num = 100;
const int *ptr1 = &num;
int const *ptr2 = &num;

// 주소 변경은 가능
int num2 = 500;
ptr1 = *num2    // *ptr1 == 500
ptr2 = *num2    // *ptr2 == 500

// 상수이기 때문에 값 변경 불가능
*ptr1 = 500;    // error
*ptr2 = 1000;   // error
```

여기서 조금 헷갈릴 수 있는데 포인터를 선언할 때 `const int` 부분과 `*ptr1` 부분을 따로 분리해서 생각해보면 쉽다.

`const int` 혹은 `int const`는 정수형 상수를 의미하고, `*ptr1`은 포인터를 의미한다. 따라서 `ptr1`은 정수형 상수를 가리키는 포인터가 된다.

그렇기 때문에 `ptr1`과 `ptr2`에서 역참조를 통해 상수값에 접근할 수는 있지만, 이 값은 상수이기 때문에 값을 바꿀 순 없다. 하지만 `*ptr`로 선언을 했기 때문에 가리키는 주소를 바꿀 순 있다.

여기서 재미있는 부분은 `num`이나 `num2`의 경우 포인터가 가리키고 있으면서, 포인터에서는 상수로 취급하지만, `num`, `num2`에 새로운 값을 할당하면 새로운 값이 역참조값으로 나오게 된다.

```cpp
int org = 100;
const int *ptr = org;

cout << *ptr << '\n'; // 100

// *ptr = 200   error
org = 200

cout << *ptr << '\n'; // 200
```

결국 상수 포인터의 경우 가리키는 주소에 저장된 값을 상수처럼 취급하기 때문에 역참조를 통해 값을 변경할 순 없지만, `org`와 같은 원 변수가 있다면 그 변수에서는 값을 변경할 수 있다. 상수 포인터를 사용할 때 주의해야 할 부분이다.

### 포인터가 상수

포인터 자체가 상수인 경우다.(pointer is const)

```cpp
int num = 100;
int *const ptr = &num;
```

포인터 자체가 상수이기 때문에 포인터가 가리키는 주소의 값이 상수처럼 취급된다. 따라서 pointer to const의 케이스와는 다르게 역참조를 통해 새로운 값을 할당하는 것은 가능하지만, 새로운 주소값을 대입하는 것은 불가능하다.

```cpp
int num = 100;
int *const ptr1 = &num;
int const *ptr2 = &num;

*ptr1 = 200;
*ptr2 = 200;    // error, 상수를 가리키는 포인터이기 때문에 역참조로 값 변경 불가

int new_num = 200;
ptr1 = &new_num;    // error, 포인터가 상수이기 때문에 주소값 변경 불가
ptr2 = &new_num;
```

따라서 `const int*`나 `int *const`나 모두 주소값을 변경하거나 역참조를 통해 값을 변경할 수 있기 때문에 포인터를 완전히 상수화 시키려면 다음과 같이 사용하면 된다.

```cpp
const int *const *ptr
```

이렇게 사용하면 `ptr`이 가리키는 주소도 변경할 수 없고, 값도 변경할 수 없게 된다.