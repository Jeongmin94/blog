---
title: "레퍼런스"
date: 2022-09-17T19:22:42+09:00
draft: true
tags:
- cpp
categories:
- cs
---
cpp의 레퍼런스에 대해 알아본다.
<!--more-->

# 레퍼런스

cpp에는 레퍼런스라는 것이 존재한다. 포인터와 비슷하게 변수나 상수를 가리키는 기능을 제공하는데, 제공되는 기능은 비슷하지만, 몇 가지 차이점들이 존재한다.

```cpp
int num = 10;
int &ref = num;

ref = 20;
cout << ref << ' ' << num;
// 20 20
```

`ref`는 레퍼런스 변수다. `num`을 가리키고 있기 때문에 `ref`의 값을 수정하면 `num`의 값도 함께 수정된다. 이렇게만 보면 포인터와 다를게 없어 보인다.

하지만 레퍼런스는 선언과 동시에 레퍼런스가 가리킬 대상을 지정해야 한다. 따라서 다음과 같은 코드에서 컴파일 에러가 발생한다.

```cpp
int &ref;       // error 레퍼런스는 선언과 동시에 초기화 필요
int num = 10;
ref = num;
```

또한, 레퍼런스가 한 번 초기화가 되면 다른 변수를 다시 레퍼런스할 수 없다. 포인터의 경우 가리킬 대상을 자유롭게 변경할 수 있는 것과는 대조적이다.

```cpp
int num = 10;
int &ref = num;

int num2 = 100;
ref = num2;     // error 다른 변수를 새로 참조할 수 없음

int *ptr = &num;
ptr = &num2;
```

레퍼런스가 가지는 독특한 특징 중 하나는 경우에 메모리에 항상 할당되지 않는다는 것이다. 레퍼런스라는 것은 참조할 변수의 별명이 되는 것으로 레퍼런스를 통해 값을 조작하거나, 원래의 변수를 통해 값을 조작하는 것은 컴파일러는 이 작업을 완전히 동일하게 취급한다.

따라서 다음과 같은 경우에는 레퍼런스가 메모리에 할당되지 않는다.

```cpp
int num = 10;
int &ref = num;     // ref는 num의 다른 이름(별명)
```

하지만 레퍼런스를 함수의 인자로 사용하게 되면 메모리에 할당이 된다.

```cpp
int sum(int &a, int &b) { return a+b; }

int main() {
    int num1 = 10;
    int num2 = 20;

    cout << sum(num1, num2);
}
```

`sum` 함수에서는 레퍼런스를 매개변수로 받는다. `sum`을 호출하면서 `num1`과 `num2`를 전달하는데, 일반적인 정수형의 변수이며, `sum`이 호출되고 스택 프레임이 만들어지면 그 때 레퍼런스 `a`와 `b`가 선언과 함께 초기화 되는 것이다.

결국 `sum` 내부에서 사용하는 `a`와 `b`는 `num1`, `num2`를 가리키는 레퍼런스가 되는데, 매개변수로 사용하지 않는 경우와 동일하게 컴파일러가 동일하게 취급을 할 것으로 생각할 수 있다.

그러나 함수는 호출되는 시점에서 스택 프레임이 생기고, 종료되는 시점에는 스택 프레임이 제거된다. 따라서 `sum`을 호출할 때 할당되는 스택 영역에 `a`와 `b` 레퍼런스의 주소는 `num1`, `num2`과 동일한 주소를 가지고 있지만, 스택 프레임이라는 새로운 공간에 메모리를 할당받게 된다.

마지막으로 상수 레퍼런스가 아닌 이상 상수에 대한 참조는 불가능하다.

```cpp
const int num = 10;
int &ref1 = num;        // error. 상수는 코드 영역에 저장되므로 읽기 전용
const int &ref2 = num;  // 상수 레퍼런스는 상수를 참조할 수 있음
```